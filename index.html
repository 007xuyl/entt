<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>entt: EnTT Framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">entt
   &#160;<span id="projectnumber">2.4.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">EnTT Framework </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/skypjack/entt"></a> <a href="https://ci.appveyor.com/project/skypjack/entt"></a> <a href="https://coveralls.io/github/skypjack/entt?branch=master"></a> <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_donations&amp;business=W2HF9FESD5LJY&amp;lc=IT&amp;item_name=Michele%20Caini&amp;currency_code=EUR&amp;bn=PP%2dDonationsBF%3abtn_donateCC_LG%2egif%3aNonHosted"></a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Introduction</h1>
<p><code>EnTT</code> is a header-only, tiny and easy to use framework written in modern C++.<br />
 It was originally designed entirely around an architectural pattern called <em>ECS</em> that is used mostly in game development. For further details:</p>
<ul>
<li><a href="http://entity-systems.wikidot.com/">Entity Systems Wiki</a></li>
<li><a href="http://cowboyprogramming.com/2007/01/05/evolve-your-heirachy/">Evolve Your Hierarchy</a></li>
<li><a href="https://en.wikipedia.org/wiki/Entity%E2%80%93component%E2%80%93system">ECS on Wikipedia</a></li>
</ul>
<p>A long time ago, the sole entity-component system was part of the project. After a while the codebase has grown and more and more classes have become part of the repository.<br />
 That's why today it's called <em>the EnTT Framework</em>.</p>
<p>Currently, <code>EnTT</code> is tested on Linux, Microsoft Windows and OS X. It has proven to work also on both Android and iOS.<br />
 Most likely it will not be problematic on other systems as well, but has not been sufficiently tested so far.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
The framework</h2>
<p><code>EnTT</code> was written initially as a faster alternative to other well known and open source entity-component systems. Nowadays the <code>EnTT</code> framework is moving its first steps. Much more will come in the future and hopefully I'm going to work on it for a long time.<br />
 Requests for feature, PR, suggestions ad feedback are highly appreciated.</p>
<p>If you find you can help me and want to contribute to the <code>EnTT</code> framework with your experience or you do want to get part of the project for some other reason, feel free to contact me directly (you can find the mail in the <a href="https://github.com/skypjack">profile</a>).<br />
 I can't promise that each and every contribution will be accepted, but I can assure that I'll do my best to take them all seriously.</p>
<h3><a class="anchor" id="autotoc_md3"></a>
State of the art</h3>
<p>Here is a brief list of what it offers today:</p>
<ul>
<li>Statically generated integer identifiers for types (assigned either at compile-time or at runtime).</li>
<li>A constexpr utility for human readable resource identifiers.</li>
<li>An incredibly fast entity-component system based on sparse sets, with its own views and a <em>pay for what you use</em> policy to adjust performance and memory pressure according to the users' requirements.</li>
<li>Actor class for those who aren't confident with entity-component systems.</li>
<li>The smallest and most basic implementation of a service locator ever seen.</li>
<li>A cooperative scheduler for processes of any type.</li>
<li>All what is needed for resource management (cache, loaders, handles).</li>
<li>Signal handlers of any type, delegates and an event bus.</li>
<li>A general purpose event emitter, that is a CRTP idiom based class template.</li>
<li>An event dispatcher for immediate and delayed events to integrate in loops.</li>
<li>...</li>
<li>Any other business.</li>
</ul>
<p>Consider it a work in progress. For more details and an updated list, please refer to the <a href="https://skypjack.github.io/entt/">online documentation</a>.</p>
<h3><a class="anchor" id="autotoc_md4"></a>
A note about the README</h3>
<p>The README file stays true to the original project and it describes only the entity-component system. However, the whole API is fully documented in-code and the <a href="https://skypjack.github.io/entt/">online documentation</a> contains much more.<br />
 Continue reading to know how the core part of the project works or follow the link above to take a look at the API reference for all other available classes.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Code Example</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;entt/entt.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>Position {</div><div class="line">    <span class="keywordtype">float</span> x;</div><div class="line">    <span class="keywordtype">float</span> y;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Velocity {</div><div class="line">    <span class="keywordtype">float</span> dx;</div><div class="line">    <span class="keywordtype">float</span> dy;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> update(<a class="code" href="classentt_1_1Registry.html">entt::DefaultRegistry</a> &amp;registry) {</div><div class="line">    <span class="keyword">auto</span> view = registry.<a class="code" href="classentt_1_1Registry.html#aed83d4c8f80ae647ee73f2a8440fa09d">view</a>&lt;Position, Velocity&gt;();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span> entity: view) {</div><div class="line">        <span class="comment">// gets only the components that are going to be used ...</span></div><div class="line"></div><div class="line">        <span class="keyword">auto</span> &amp;velocity = view.get&lt;Velocity&gt;(entity);</div><div class="line"></div><div class="line">        velocity.dx = 0.;</div><div class="line">        velocity.dy = 0.;</div><div class="line"></div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> update(std::uint64_t dt, <a class="code" href="classentt_1_1Registry.html">entt::DefaultRegistry</a> &amp;registry) {</div><div class="line">    registry.<a class="code" href="classentt_1_1Registry.html#aed83d4c8f80ae647ee73f2a8440fa09d">view</a>&lt;Position, Velocity&gt;().each([dt](<span class="keyword">auto</span> entity, <span class="keyword">auto</span> &amp;position, <span class="keyword">auto</span> &amp;velocity) {</div><div class="line">        <span class="comment">// gets all the components of the view at once ...</span></div><div class="line"></div><div class="line">        position.x += velocity.dx * dt;</div><div class="line">        position.y += velocity.dy * dt;</div><div class="line"></div><div class="line">        <span class="comment">// ...</span></div><div class="line">    });</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="classentt_1_1Registry.html">entt::DefaultRegistry</a> registry;</div><div class="line">    std::uint64_t dt = 16;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span> i = 0; i &lt; 10; ++i) {</div><div class="line">        <span class="keyword">auto</span> entity = registry.<a class="code" href="classentt_1_1Registry.html#a68363417c654ab36e68606c13deb850e">create</a>(Position{i * 1.f, i * 1.f});</div><div class="line">        <span class="keywordflow">if</span>(i % 2 == 0) { registry.<a class="code" href="classentt_1_1Registry.html#aa6b578d40a9305869e692167fc3dcddf">assign</a>&lt;Velocity&gt;(entity, i * .1f, i * .1f); }</div><div class="line">    }</div><div class="line"></div><div class="line">    update(dt, registry);</div><div class="line">    update(registry);</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="autotoc_md6"></a>
Motivation</h2>
<p>I started working on <code>EnTT</code> because of the wrong reason: my goal was to design an entity-component system that beated another well known open source solution in terms of performance.<br />
 In the end, I did it, but it wasn't much satisfying. Actually it wasn't satisfying at all. The fastest and nothing more, fairly little indeed. When I realized it, I tried hard to keep intact the great performance of <code>EnTT</code> and to add all the features I wanted to see in <em>my</em> entity-component system at the same time.</p>
<p>Today <code>EnTT</code> is finally what I was looking for: still faster than its <em>competitors</em>, a really good API and an amazing set of features. And even more, of course.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Performance</h2>
<p>As it stands right now, <code>EnTT</code> is just fast enough for my requirements if compared to my first choice (it was already amazingly fast actually).<br />
 Here is a comparision between the two (both of them compiled with GCC 7.2.0 on a Dell XPS 13 out of the mid 2014):</p>
<table class="doxtable">
<tr>
<th>Benchmark </th><th>EntityX (compile-time) </th><th>EnTT  </th></tr>
<tr>
<td>Create 10M entities </td><td>0.1289s </td><td><b>0.0409s</b> </td></tr>
<tr>
<td>Destroy 10M entities </td><td><b>0.0531s</b> </td><td>0.0546s </td></tr>
<tr>
<td>Standard view, 10M entities, one component </td><td>0.0107s </td><td><b>1.6e-07s</b> </td></tr>
<tr>
<td>Standard view, 10M entities, two components </td><td><b>0.0113s</b> </td><td>0.0295s </td></tr>
<tr>
<td>Standard view, 10M entities, two components<br />
Half of the entities have all the components </td><td><b>0.0078s</b> </td><td>0.0150s </td></tr>
<tr>
<td>Standard view, 10M entities, two components<br />
One of the entities has all the components </td><td>0.0071s </td><td><b>8.8e-07s</b> </td></tr>
<tr>
<td>Persistent view, 10M entities, two components </td><td>0.0113s </td><td><b>5.7e-07s</b> </td></tr>
<tr>
<td>Standard view, 10M entities, five components </td><td><b>0.0091s</b> </td><td>0.0688s </td></tr>
<tr>
<td>Persistent view, 10M entities, five components </td><td>0.0091s </td><td><b>2.9e-07s</b> </td></tr>
<tr>
<td>Standard view, 10M entities, ten components </td><td><b>0.0105s</b> </td><td>0.1403s </td></tr>
<tr>
<td>Standard view, 10M entities, ten components<br />
Half of the entities have all the components </td><td><b>0.0090s</b> </td><td>0.0620s </td></tr>
<tr>
<td>Standard view, 10M entities, ten components<br />
One of the entities has all the components </td><td>0.0070s </td><td><b>1.3e-06s</b> </td></tr>
<tr>
<td>Persistent view, 10M entities, ten components </td><td>0.0105s </td><td><b>6.2e-07s</b> </td></tr>
<tr>
<td>Sort 150k entities, one component<br />
Arrays are in reverse order </td><td>- </td><td><b>0.0043s</b> </td></tr>
<tr>
<td>Sort 150k entities, enforce permutation<br />
Arrays are in reverse order </td><td>- </td><td><b>0.0006s</b> </td></tr>
</table>
<p><code>EnTT</code> includes its own tests and benchmarks. See <a href="https://github.com/skypjack/entt/blob/master/test/benchmark.cpp">benchmark.cpp</a> for further details.<br />
 On Github users can find also a <a href="https://github.com/abeimler/ecs_benchmark">benchmark suite</a> that compares a bunch of different projects, one of which is <code>EnTT</code>.</p>
<p>Probably I'll try to get out of <code>EnTT</code> more features and better performance in the future, mainly for fun.<br />
 If you want to contribute and/or have any suggestion, feel free to make a PR or open an issue to discuss your idea.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Build Instructions</h1>
<h2><a class="anchor" id="autotoc_md9"></a>
Requirements</h2>
<p>To be able to use <code>EnTT</code>, users must provide a full-featured compiler that supports at least C++14.<br />
 The requirements below are mandatory to compile the tests and to extract the documentation:</p>
<ul>
<li>CMake version 3.2 or later.</li>
<li>Doxygen version 1.8 or later.</li>
</ul>
<h2><a class="anchor" id="autotoc_md10"></a>
Library</h2>
<p><code>EnTT</code> is a header-only library. This means that including the <code><a class="el" href="entt_8hpp_source.html">entt.hpp</a></code> header is enough to include the whole framework and use it. For those who are interested only in the entity-component system, consider to include the sole <code><a class="el" href="registry_8hpp_source.html">entity/registry.hpp</a></code> header instead.<br />
 It's a matter of adding the following line to the top of a file:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;entt/entt.hpp&gt;</span></div></div><!-- fragment --><p>Use the line below to include only the entity-component system instead:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;entt/entity/registry.hpp&gt;</span></div></div><!-- fragment --><p>Then pass the proper <code>-I</code> argument to the compiler to add the <code>src</code> directory to the include paths.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Documentation</h2>
<p>The documentation is based on <a href="http://www.stack.nl/~dimitri/doxygen/">doxygen</a>. To build it: </p><pre class="fragment">$ cd build
$ cmake ..
$ make docs
</pre><p>The API reference will be created in HTML format within the directory <code>build/docs/html</code>. To navigate it with your favorite browser: </p><pre class="fragment">$ cd build
$ your_favorite_browser docs/html/index.html
</pre><p>The API reference is also available <a href="https://skypjack.github.io/entt/">online</a> for the latest version.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Tests</h2>
<p>To compile and run the tests, <code>EnTT</code> requires <em>googletest</em>.<br />
 <code>cmake</code> will download and compile the library before to compile anything else.</p>
<p>To build the tests:</p>
<ul>
<li><code>$ cd build</code></li>
<li><code>$ cmake ..</code></li>
<li><code>$ make</code></li>
<li><code>$ make test</code></li>
</ul>
<p>To build the benchmarks, use the following line instead:</p>
<ul>
<li><code>$ cmake -DCMAKE_BUILD_TYPE=Release ..</code></li>
</ul>
<p>Benchmarks are compiled only in release mode currently.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Crash Course</h1>
<h2><a class="anchor" id="autotoc_md14"></a>
Design choices</h2>
<h3><a class="anchor" id="autotoc_md15"></a>
A bitset-free entity-component system</h3>
<p><code>EnTT</code> is a <em>bitset-free</em> entity-component system that doesn't require users to specify the component set at compile-time.<br />
 This is why users can instantiate the core class simply like:</p>
<div class="fragment"><div class="line"><a class="code" href="classentt_1_1Registry.html">entt::DefaultRegistry</a> registry;</div></div><!-- fragment --><p>In place of its more annoying and error-prone counterpart:</p>
<div class="fragment"><div class="line"><a class="code" href="classentt_1_1Registry.html">entt::DefaultRegistry</a>&lt;Comp0, Comp1, ..., CompN&gt; registry;</div></div><!-- fragment --><h3><a class="anchor" id="autotoc_md16"></a>
Pay per use</h3>
<p><code>EnTT</code> is entirely designed around the principle that users have to pay only for what they want.</p>
<p>When it comes to using an entity-componet system, the tradeoff is usually between performance and memory usage. The faster it is, the more memory it uses. However, slightly worse performance along non-critical paths are the right price to pay to reduce memory usage and I've always wondered why this kind of tools do not leave me the choice.<br />
 <code>EnTT</code> follows a completely different approach. It squezees the best from the basic data structures and gives users the possibility to pay more for higher performance where needed.<br />
 The disadvantage of this approach is that users need to know the systems they are working on and the tools they are using. Otherwise, the risk to ruin the performance along critical paths is high.</p>
<p>So far, this choice has proven to be a good one and I really hope it can be for many others besides me.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Vademecum</h2>
<p>The <code>Registry</code> to store, the <code>View</code>s to iterate. That's all.</p>
<p>An entity (the <em>E</em> of an <em>ECS</em>) is an opaque identifier that users should just use as-is and store around if needed. Do not try to inspect an entity identifier, its type can change in future and a registry offers all the functionalities to query them out-of-the-box. The underlying type of an entity (either <code>std::uint16_t</code>, <code>std::uint32_t</code> or <code>std::uint64_t</code>) can be specified when defining a registry (actually the DefaultRegistry is nothing more than a Registry where the type of the entities is <code>std::uint32_t</code>).<br />
 Components (the <em>C</em> of an <em>ECS</em>) should be plain old data structures or more complex and moveable data structures with a proper constructor. Actually, the sole requirement of a component type is that it must be both move constructible and move assignable. They are list initialized by using the parameters provided to construct the component itself. No need to register components or their types neither with the registry nor with the entity-component system at all.<br />
 Systems (the <em>S</em> of an <em>ECS</em>) are just plain functions, functors, lambdas or whatever the users want. They can accept a Registry, a View or a PersistentView and use them the way they prefer. No need to register systems or their types neither with the registry nor with the entity-component system at all.</p>
<p>The following sections will explain in short how to use the entity-component system, the core part of the whole framework.<br />
 In fact, the framework is composed of many other classes in addition to those describe below. For more details, please refer to the <a href="https://skypjack.github.io/entt/">online documentation</a>.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
The Registry, the Entity and the Component</h2>
<p>A registry is used to store and manage entities as well as to create views to iterate the underlying data structures.<br />
 Registry is a class template that lets the users decide what's the preferred type to represent an entity. Because <code>std::uint32_t</code> is large enough for almost all the cases, there exists also an alias named DefaultRegistry for <code>Registry&lt;std::uint32_t&gt;</code>.</p>
<p>Entities are represented by <em>entitiy identifiers</em>. An entity identifier is an opaque type that users should not inspect or modify in any way. It carries information about the entity itself and its version.</p>
<p>A registry can be used both to construct and to destroy entities:</p>
<div class="fragment"><div class="line"><span class="comment">// constructs a naked entity with no components ad returns its identifier</span></div><div class="line"><span class="keyword">auto</span> entity = registry.create();</div><div class="line"></div><div class="line"><span class="comment">// constructs an entity and assigns it default-initialized components</span></div><div class="line"><span class="keyword">auto</span> another = registry.create&lt;Position, Velocity&gt;();</div><div class="line"></div><div class="line"><span class="comment">// destroys an entity and all its components</span></div><div class="line">registry.destroy(entity);</div></div><!-- fragment --><p>Once an entity is deleted, the registry can freely reuse it internally with a slightly different identifier. In particular, the version of an entity is increased each and every time it's destroyed.<br />
 In case entity identifiers are stored around, the registry offers all the functionalities required to test them and get out of the them all the information they carry:</p>
<div class="fragment"><div class="line"><span class="comment">// returns true if the entity is still valid, false otherwise</span></div><div class="line"><span class="keywordtype">bool</span> b = registry.valid(entity);</div><div class="line"></div><div class="line"><span class="comment">// gets the version contained in the entity identifier</span></div><div class="line"><span class="keyword">auto</span> version = registry.version(entity);</div><div class="line"></div><div class="line"><span class="comment">// gets the actual version for the given entity</span></div><div class="line"><span class="keyword">auto</span> curr = registry.current(entity);</div></div><!-- fragment --><p>Components can be assigned to or removed from entities at any time with a few calls to member functions of the registry. As for the entities, the registry offers also a set of functionalities users can use to work with the components.</p>
<p>The <code>assign</code> member function template creates, initializes and assigns to an entity the given component. It accepts a variable number of arguments that are used to construct the component itself if present:</p>
<div class="fragment"><div class="line">registry.assign&lt;Position&gt;(entity, 0., 0.);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">Velocity &amp;velocity = registry.assign&lt;Velocity&gt;(entity);</div><div class="line">velocity.dx = 0.;</div><div class="line">velocity.dy = 0.;</div></div><!-- fragment --><p>If the entity already has the given component, the <code>replace</code> member function template can be used to replace it:</p>
<div class="fragment"><div class="line">registry.replace&lt;Position&gt;(entity, 0., 0.);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">Velocity &amp;velocity = registry.replace&lt;Velocity&gt;(entity);</div><div class="line">velocity.dx = 0.;</div><div class="line">velocity.dy = 0.;</div></div><!-- fragment --><p>In case users want to assign a component to an entity, but it's unknown whether the entity already has it or not, <code>accomodate</code> does the work in a single call (there is a performance penalty to pay for this mainly due to the fact that it has to check if <code>entity</code> already has the given component or not):</p>
<div class="fragment"><div class="line">registry.accomodate&lt;Position&gt;(entity, 0., 0.);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">Velocity &amp;velocity = registry.accomodate&lt;Velocity&gt;(entity);</div><div class="line">velocity.dx = 0.;</div><div class="line">velocity.dy = 0.;</div></div><!-- fragment --><p>Note that <code>accomodate</code> is a sliglhty faster alternative for the following <code>if</code>/<code>else</code> statement and nothing more:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(registry.has&lt;Comp&gt;(entity)) {</div><div class="line">    registry.replace&lt;Comp&gt;(entity, arg1, argN);</div><div class="line">} <span class="keywordflow">else</span> {</div><div class="line">    registry.assign&lt;Comp&gt;(entity, arg1, argN);</div><div class="line">}</div></div><!-- fragment --><p>As already shown, if in doubt about whether or not an entity has one or more components, the <code>has</code> member function template may be useful:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> b = registry.has&lt;Position, Velocity&gt;(entity);</div></div><!-- fragment --><p>On the other side, if the goal is to delete a single component, the <code>remove</code> member function template is the way to go when it's certain that the entity owns a copy of the component:</p>
<div class="fragment"><div class="line">registry.remove&lt;Position&gt;(entity);</div></div><!-- fragment --><p>Otherwise consider to use the <code>reset</code> member function. It behaves similarly to <code>remove</code> but with a strictly defined behaviour (and a performance penalty is the price to pay for this). In particular it removes the component if and only if it exists, otherwise it returns safely to the caller:</p>
<div class="fragment"><div class="line">registry.reset&lt;Position&gt;(entity);</div></div><!-- fragment --><p>There exist also two other <em>versions</em> of the <code>reset</code> member function:</p>
<ul>
<li>If no entity is passed to it, <code>reset</code> will remove the given component from each entity that has it:</li>
</ul>
<div class="fragment"><div class="line">registry.reset&lt;Position&gt;();</div></div><!-- fragment --><ul>
<li>If neither the entity nor the component are specified, all the entities and their components are destroyed:</li>
</ul>
<div class="fragment"><div class="line">registry.reset();</div></div><!-- fragment --><p>Finally, references to components can be retrieved simply by doing this:</p>
<div class="fragment"><div class="line"><a class="code" href="classentt_1_1Registry.html">entt::DefaultRegistry</a> registry;</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;cregistry = registry;</div><div class="line"></div><div class="line"><span class="comment">// const and non-const reference</span></div><div class="line"><span class="keyword">const</span> Position &amp;position = cregistry.<a class="code" href="classentt_1_1Registry.html#aad2f79d8d9637a5f666a7121f379a0dd">get</a>&lt;Position&gt;(entity);</div><div class="line">Position &amp;position = registry.<a class="code" href="classentt_1_1Registry.html#aad2f79d8d9637a5f666a7121f379a0dd">get</a>&lt;Position&gt;(entity);</div><div class="line"></div><div class="line"><span class="comment">// const and non-const references</span></div><div class="line">std::tuple&lt;const Position &amp;, const Velocity &amp;&gt; tup = cregistry.get&lt;Position, Velocity&gt;(entity);</div><div class="line">std::tuple&lt;Position &amp;, Velocity &amp;&gt; tup = registry.<a class="code" href="classentt_1_1Registry.html#aad2f79d8d9637a5f666a7121f379a0dd">get</a>&lt;Position, Velocity&gt;(entity);</div></div><!-- fragment --><p>The <code>get</code> member function template gives direct access to the component of an entity stored in the underlying data structures of the registry.</p>
<h3><a class="anchor" id="autotoc_md19"></a>
Single instance components</h3>
<p>In those cases where all what is needed is a single instance component, tags are the right tool to achieve the purpose.<br />
 Tags undergo the same requirements of components. They can be either plain old data structures or more complex and moveable data structures with a proper constructor.<br />
 Actually, the same type can be used both as a tag and as a component and the registry will not complain about it. It is up to the users to properly manage their own types.</p>
<p>Attaching tags to entities and removing them is trivial:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> player = registry.<a class="code" href="classentt_1_1Registry.html#a68363417c654ab36e68606c13deb850e">create</a>();</div><div class="line"><span class="keyword">auto</span> camera = registry.<a class="code" href="classentt_1_1Registry.html#a68363417c654ab36e68606c13deb850e">create</a>();</div><div class="line"></div><div class="line"><span class="comment">// attaches a default-initialized tag to an entity</span></div><div class="line">registry.<a class="code" href="classentt_1_1Registry.html#ad6aba3339872b3dccc722debcdf4d65c">attach</a>&lt;PlayingCharacter&gt;(player);</div><div class="line"></div><div class="line"><span class="comment">// attaches a tag to an entity and initializes it</span></div><div class="line">registry.<a class="code" href="classentt_1_1Registry.html#ad6aba3339872b3dccc722debcdf4d65c">attach</a>&lt;Camera&gt;(camera, player);</div><div class="line"></div><div class="line"><span class="comment">// removes tags from their owners</span></div><div class="line">registry.<a class="code" href="classentt_1_1Registry.html#a957bcbdbf082f9767e5474a73be6ece4">remove</a>&lt;PlayingCharacter&gt;();</div><div class="line">registry.<a class="code" href="classentt_1_1Registry.html#a957bcbdbf082f9767e5474a73be6ece4">remove</a>&lt;Camera&gt;();</div></div><!-- fragment --><p>If in doubt about whether or not a tag has already an owner, the <code>has</code> member function template may be useful:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> b = registry.<a class="code" href="classentt_1_1Registry.html#ac17c42321f66e42649d1b0e549828620">has</a>&lt;PlayingCharacter&gt;();</div></div><!-- fragment --><p>References to tags can be retrieved simply by doing this:</p>
<div class="fragment"><div class="line"><span class="comment">// either a non-const reference ...</span></div><div class="line"><a class="code" href="classentt_1_1Registry.html">entt::DefaultRegistry</a> registry;</div><div class="line">PlayingCharacter &amp;player = registry.<a class="code" href="classentt_1_1Registry.html#aad2f79d8d9637a5f666a7121f379a0dd">get</a>&lt;PlayingCharacter&gt;();</div><div class="line"></div><div class="line"><span class="comment">// ... or a const one</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;cregistry = registry;</div><div class="line"><span class="keyword">const</span> Camera &amp;camera = cregistry.<a class="code" href="classentt_1_1Registry.html#aad2f79d8d9637a5f666a7121f379a0dd">get</a>&lt;Camera&gt;();</div></div><!-- fragment --><p>The <code>get</code> member function template gives direct access to the tag as stored in the underlying data structures of the registry.</p>
<p>As shown above, in almost all the cases the entity identifier isn't required, since a single instance component can have only one associated entity and therefore it doesn't make much sense to mention it explicitly.<br />
 To find out who the owner is, just do the following:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> player = registry.<a class="code" href="classentt_1_1Registry.html#a9300c3ef37bc0abb7ebc5dac7b2fc873">attachee</a>&lt;PlayingCharacter&gt;();</div></div><!-- fragment --><p>Note that iterating tags isn't possible for obvious reasons. Tags give direct access to single entities and nothing more.</p>
<h3><a class="anchor" id="autotoc_md20"></a>
Runtime components</h3>
<p>Defining components at runtime is useful to support plugins and mods in general. However, it seems impossible with a tool designed around a bunch of templates. Indeed it's not that difficult.<br />
 Of course, some features cannot be easily exported into a runtime environment. As an example, sorting a group of components defined at runtime isn't for free if compared to most of the other operations. However, the basic functionalities of an entity-component system such as <code>EnTT</code> fit the problem perfectly and can also be used to manage runtime components if required.<br />
 All that is necessary to do it is to know the identifiers of the components. An identifier is nothing more than a number or similar that can be used at runtime to work with the type system.</p>
<p>In <code>EnTT</code>, identifiers are easily accessible:</p>
<div class="fragment"><div class="line"><a class="code" href="classentt_1_1Registry.html">entt::DefaultRegistry</a> registry;</div><div class="line"></div><div class="line"><span class="comment">// standard component identifier</span></div><div class="line"><span class="keyword">auto</span> ctype = registry.<a class="code" href="classentt_1_1Registry.html#ab284cde58cbc42cf0e929edc857f5182">component</a>&lt;Position&gt;();</div><div class="line"></div><div class="line"><span class="comment">// single instance component identifier</span></div><div class="line"><span class="keyword">auto</span> ttype = registry.<a class="code" href="classentt_1_1Registry.html#a307aa3a1d24923f34d1e8a595c82649f">tag</a>&lt;PlayingCharacter&gt;();</div></div><!-- fragment --><p>Once the identifiers are made available, almost everything becomes pretty simple.</p>
<h4><a class="anchor" id="autotoc_md21"></a>
A journey through a plugin</h4>
<p><code>EnTT</code> comes with an example (actually a test) that shows how to integrate compile-time and runtime components in a stack based JavaScript environment. It uses <a href="https://github.com/svaarala/duktape"><code>duktape</code></a> under the hood, mainly because I wanted to learn how it works at the time I was writing the code.</p>
<p>It's not production-ready and overall performance can be highly improved. However, I sacrificed optimizations in favor of a more readable piece of code. I hope I succeeded.<br />
 Note also that this isn't neither the only nor (probably) the best way to do it. In fact, the right way depends on the scripting language and the problem one is facing in general.</p>
<p>The basic idea is that of creating a compile-time component aimed to map all the runtime components assigned to an entity.<br />
 Identifiers come in use to address the right function from a map when invoked from the runtime environment and to filter entities when iterating.<br />
 With a bit of gymnastic, one can narrow views and improve the performance to some extent but it was not the goal of the example.</p>
<h3><a class="anchor" id="autotoc_md22"></a>
Sorting: is it possible?</h3>
<p>It goes without saying that sorting entities and components is possible with <code>EnTT</code>.<br />
 In fact, there are two functions that respond to slightly different needs:</p>
<ul>
<li>Components can be sorted directly:</li>
</ul>
<div class="fragment"><div class="line">registry.<a class="code" href="classentt_1_1Registry.html#a625ada828ff48c153c7be14cc99eeca5">sort</a>&lt;Renderable&gt;([](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;lhs, <span class="keyword">const</span> <span class="keyword">auto</span> &amp;rhs) {</div><div class="line">    <span class="keywordflow">return</span> lhs.z &lt; rhs.z;</div><div class="line">});</div></div><!-- fragment --><ul>
<li>Components can be sorted according to the order imposed by another component:</li>
</ul>
<div class="fragment"><div class="line">registry.<a class="code" href="classentt_1_1Registry.html#a625ada828ff48c153c7be14cc99eeca5">sort</a>&lt;Movement, Physics&gt;();</div></div><!-- fragment --><p>In this case, instances of <code>Movement</code> are arranged in memory so that cache misses are minimized when the two components are iterated together.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
View: to persist or not to persist?</h2>
<p>There are mainly two kinds of views: standard (also known as View) and persistent (alsa known as PersistentView).<br />
 Both of them have pros and cons to take in consideration. In particular:</p>
<ul>
<li><p class="startli">Standard views:</p>
<p class="startli">Pros:</p><ul>
<li>They work out-of-the-box and don't require any dedicated data structure.</li>
<li>Creating and destroying them isn't expensive at all because they don't have any type of initialization.</li>
<li>They are the best tool to iterate single components.</li>
<li>They are the best tool to iterate multiple components at once when tags are involved or one of the component is assigned to a significantly low number of entities.</li>
<li>They don't affect any other operations of the registry.</li>
</ul>
<p class="startli">Cons:</p><ul>
<li>Their performance tend to degenerate when the number of components to iterate grows up and the most of the entities have all of them.</li>
</ul>
</li>
<li><p class="startli">Persistent views:</p>
<p class="startli">Pros:</p><ul>
<li>Once prepared, creating and destroying them isn't expensive at all because they don't have any type of initialization.</li>
<li>They are the best tool to iterate multiple components at once when the most of the entities have all of them.</li>
</ul>
<p class="startli">Cons:</p><ul>
<li>They have dedicated data structures and thus affect the memory pressure to a minimal extent.</li>
<li>If not previously prepared, the first time they are used they go through an initialization step that could take a while.</li>
<li>They affect to a minimum the creation and destruction of entities and components. In other terms: the more persistent views there will be, the less performing will be creating and destroying entities and components.</li>
</ul>
</li>
</ul>
<p>To sum up and as a rule of thumb, use a standard view:</p><ul>
<li>To iterate entities for a single component.</li>
<li>To iterate entities for multiple components when a significantly low number of entities have one of the components.</li>
<li>In all those cases where a persistent view would give a boost to performance but the iteration isn't performed frequently.</li>
</ul>
<p>Use a persistent view in all the other cases.</p>
<p>To easily iterate entities, all the views offer the common <code>begin</code> and <code>end</code> member functions that allow users to use a view in a typical range-for loop.<br />
 Continue reading for more details or refer to the <a href="https://skypjack.github.io/entt/">official documentation</a>.</p>
<h3><a class="anchor" id="autotoc_md24"></a>
Standard View</h3>
<p>A standard view behaves differently if it's constructed for a single component or if it has been requested to iterate multiple components. Even the API is different in the two cases.<br />
 All that they share is the way they are created by means of a registry:</p>
<div class="fragment"><div class="line"><span class="comment">// single component standard view</span></div><div class="line"><span class="keyword">auto</span> single = registry.<a class="code" href="classentt_1_1Registry.html#aed83d4c8f80ae647ee73f2a8440fa09d">view</a>&lt;Position&gt;();</div><div class="line"></div><div class="line"><span class="comment">// multi component standard view</span></div><div class="line"><span class="keyword">auto</span> multi = registry.<a class="code" href="classentt_1_1Registry.html#aed83d4c8f80ae647ee73f2a8440fa09d">view</a>&lt;Position, Velocity&gt;();</div></div><!-- fragment --><p>For all that remains, it's worth discussing them separately.<br />
</p>
<h4><a class="anchor" id="autotoc_md25"></a>
Single component standard view</h4>
<p>Single component standard views are specialized in order to give a boost in terms of performance in all the situation. This kind of views can access the underlying data structures directly and avoid superflous checks.<br />
 They offer a bunch of functionalities to get the number of entities they are going to return and a raw access to the entity list as well as to the component list.<br />
 Refer to the <a href="https://skypjack.github.io/entt/">official documentation</a> for all the details.</p>
<p>There is no need to store views around for they are extremely cheap to construct, even though they can be copied without problems and reused freely. In fact, they return newly created and correctly initialized iterators whenever <code>begin</code> or <code>end</code> are invoked.<br />
 To iterate a single component standard view, either use it in range-for loop:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> view = registry.<a class="code" href="classentt_1_1Registry.html#aed83d4c8f80ae647ee73f2a8440fa09d">view</a>&lt;Renderable&gt;();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> entity: view) {</div><div class="line">    Renderable &amp;renderable = view.get(entity);</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div></div><!-- fragment --><p>Or rely on the <code>each</code> member function to iterate entities and get all their components at once:</p>
<div class="fragment"><div class="line">registry.<a class="code" href="classentt_1_1Registry.html#aed83d4c8f80ae647ee73f2a8440fa09d">view</a>&lt;Renderable&gt;().each([](<span class="keyword">auto</span> entity, <span class="keyword">auto</span> &amp;renderable) {</div><div class="line">    <span class="comment">// ...</span></div><div class="line">});</div></div><!-- fragment --><p>Performance are more or less the same. The best approach depends mainly on whether all the components have to be accessed or not.</p>
<p><b>Note</b>: prefer the <code>get</code> member function of a view instead of the <code>get</code> member function template of a registry during iterations, if possible. However, keep in mind that it works only with the components of the view itself.</p>
<h4><a class="anchor" id="autotoc_md26"></a>
Multi component standard view</h4>
<p>Multi component standard views iterate entities that have at least all the given components in their bags. During construction, these views look at the number of entities available for each component and pick up a reference to the smallest set of candidates in order to speed up iterations.<br />
 They offer fewer functionalities than their companion views for single component, the most important of which can be used to reset the view and refresh the reference to the set of candidate entities to iterate.<br />
 Refer to the <a href="https://skypjack.github.io/entt/">official documentation</a> for all the details.</p>
<p>There is no need to store views around for they are extremely cheap to construct, even though they can be copied without problems and reused freely. In fact, they return newly created and correctly initialized iterators whenever <code>begin</code> or <code>end</code> are invoked.<br />
 To iterate a multi component standard view, either use it in range-for loop:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> view = registry.<a class="code" href="classentt_1_1Registry.html#aed83d4c8f80ae647ee73f2a8440fa09d">view</a>&lt;Position, Velocity&gt;();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> entity: view) {</div><div class="line">    <span class="comment">// a component at a time ...</span></div><div class="line">    Position &amp;position = view.get&lt;Position&gt;(entity);</div><div class="line">    Velocity &amp;velocity = view.get&lt;Velocity&gt;(entity);</div><div class="line"></div><div class="line">    <span class="comment">// ... or multiple components at once</span></div><div class="line">    std::tuple&lt;Position &amp;, Velocity &amp;&gt; tup = view.get&lt;Position, Velocity&gt;(entity);</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div></div><!-- fragment --><p>Or rely on the <code>each</code> member function to iterate entities and get all their components at once:</p>
<div class="fragment"><div class="line">registry.<a class="code" href="classentt_1_1Registry.html#aed83d4c8f80ae647ee73f2a8440fa09d">view</a>&lt;Position, Velocity&gt;().each([](<span class="keyword">auto</span> entity, <span class="keyword">auto</span> &amp;position, <span class="keyword">auto</span> &amp;velocity) {</div><div class="line">    <span class="comment">// ...</span></div><div class="line">});</div></div><!-- fragment --><p>Performance are more or less the same. The best approach depends mainly on whether all the components have to be accessed or not.</p>
<p><b>Note</b>: prefer the <code>get</code> member function of a view instead of the <code>get</code> member function template of a registry during iterations, if possible. However, keep in mind that it works only with the components of the view itself.</p>
<h3><a class="anchor" id="autotoc_md27"></a>
Persistent View</h3>
<p>A persistent view returns all the entities and only the entities that have at least the given components. Moreover, it's guaranteed that the entity list is thightly packed in memory for fast iterations.<br />
 In general, persistent views don't stay true to the order of any set of components unless users explicitly sort them.</p>
<p>Persistent views can be used only to iterate multiple components. Create them as it follows:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> view = registry.<a class="code" href="classentt_1_1Registry.html#a139a4d7b711fc1813c6c4520b9e79c09">persistent</a>&lt;Position, Velocity&gt;();</div></div><!-- fragment --><p>There is no need to store views around for they are extremely cheap to construct, even though they can be copied without problems and reused freely. In fact, they return newly created and correctly initialized iterators whenever <code>begin</code> or <code>end</code> are invoked.<br />
 That being said, persistent views perform an initialization step the very first time they are constructed and this could be quite costly. To avoid it, consider asking to the registry to <em>prepare</em> them when no entities have been created yet:</p>
<div class="fragment"><div class="line">registry.<a class="code" href="classentt_1_1Registry.html#ac05c9ccc5fe57df386d8104578fc9675">prepare</a>&lt;Position, Velocity&gt;();</div></div><!-- fragment --><p>If the registry is empty, preparation is extremely fast. Moreover the <code>prepare</code> member function template is idempotent. Feel free to invoke it even more than once: if the view has been alreadt prepared before, the function returns immediately and does nothing.</p>
<p>A persistent view offers a bunch of functionalities to get the number of entities it's going to return, a raw access to the entity list and the possibility to sort the underlying data structures according to the order of one of the components for which it has been constructed.<br />
 Refer to the <a href="https://skypjack.github.io/entt/">official documentation</a> for all the details.</p>
<p>To iterate a persistent view, either use it in range-for loop:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> view = registry.<a class="code" href="classentt_1_1Registry.html#a139a4d7b711fc1813c6c4520b9e79c09">persistent</a>&lt;Position, Velocity&gt;();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> entity: view) {</div><div class="line">    <span class="comment">// a component at a time ...</span></div><div class="line">    Position &amp;position = view.get&lt;Position&gt;(entity);</div><div class="line">    Velocity &amp;velocity = view.get&lt;Velocity&gt;(entity);</div><div class="line"></div><div class="line">    <span class="comment">// ... or multiple components at once</span></div><div class="line">    std::tuple&lt;Position &amp;, Velocity &amp;&gt; tup = view.get&lt;Position, Velocity&gt;(entity);</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div></div><!-- fragment --><p>Or rely on the <code>each</code> member function to iterate entities and get all their components at once:</p>
<div class="fragment"><div class="line">registry.<a class="code" href="classentt_1_1Registry.html#a139a4d7b711fc1813c6c4520b9e79c09">persistent</a>&lt;Position, Velocity&gt;().each([](<span class="keyword">auto</span> entity, <span class="keyword">auto</span> &amp;position, <span class="keyword">auto</span> &amp;velocity) {</div><div class="line">    <span class="comment">// ...</span></div><div class="line">});</div></div><!-- fragment --><p>Performance are more or less the same. The best approach depends mainly on whether all the components have to be accessed or not.</p>
<p><b>Note</b>: prefer the <code>get</code> member function of a view instead of the <code>get</code> member function template of a registry during iterations, if possible. However, keep in mind that it works only with the components of the view itself.</p>
<h3><a class="anchor" id="autotoc_md28"></a>
Give me everything</h3>
<p>Views are narrow windows on the entire list of entities. They work by filtering entities according to their components.<br />
 In some cases there may be the need to iterate all the entities regardless of their components. The registry offers a specific member function to do that:</p>
<div class="fragment"><div class="line">registry.<a class="code" href="classentt_1_1Registry.html#a1d7547f6d8503265480d235fe48dfb1d">each</a>([](<span class="keyword">auto</span> entity) {</div><div class="line">    <span class="comment">// ...</span></div><div class="line">});</div></div><!-- fragment --><p>Each entity ever created is returned, no matter if it's in use or not.<br />
 Usually, filtering entities that aren't currently in use is more expensive than iterating them all and filtering out those in which one isn't interested.</p>
<p>As a rule of thumb, consider using a view if the goal is to iterate entities that have a determinate set of components. A view is usually faster than combining this function with a bunch of custom tests.<br />
 In all the other cases, this is the way to go.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Side notes</h2>
<ul>
<li>Entity identifiers are numbers and nothing more. They are not classes and they have no member functions at all. As already mentioned, do no try to inspect or modify an entity descriptor in any way.</li>
<li>As shown in the examples above, the preferred way to get references to the components while iterating a view is by using the view itself. It's a faster alternative to the <code>get</code> member function template that is part of the API of the Registry. This is because the registry must ensure that a pool for the given component exists before to use it; on the other side, views force the construction of the pools for all their components and access them directly, thus avoiding all the checks.</li>
<li><p class="startli">Most of the <em>ECS</em> available out there have an annoying limitation (at least from my point of view): entities and components cannot be created and/or deleted during iterations.<br />
 <code>EnTT</code> partially solves the problem with a few limitations:</p><ul>
<li>Creating entities and components is allowed during iterations.</li>
<li>Deleting an entity or removing its components is allowed during iterations if it's the one currently returned by a view. For all the other entities, destroying them or removing their components isn't allowed and it can result in undefined behavior.</li>
</ul>
<p class="startli">Iterators are invalidated and the behaviour is undefined if an entity is modified or destroyed and it's not the one currently returned by the view.<br />
 To work around it, possible approaches are:</p><ul>
<li>Store aside the entities and the components to be removed and perform the operations at the end of the iteration.</li>
<li>Mark entities and components with a proper tag component that indicates they must be purged, then perform a second iteration to clean them up one by one.</li>
</ul>
</li>
<li>Views and thus their iterators aren't thread safe. Do no try to iterate a set of components and modify the same set concurrently.<br />
 That being said, as long as a thread iterates the entities that have the component <code>X</code> or assign and removes that component from a set of entities, another thread can safely do the same with components <code>Y</code> and <code>Z</code> and everything will work like a charm.<br />
 As an example, users can freely execute the rendering system and iterate the renderable entities while updating a physic component concurrently on a separate thread if needed.</li>
</ul>
<h1><a class="anchor" id="autotoc_md30"></a>
Contributors</h1>
<p>If you want to contribute, please send patches as pull requests against the branch <code>master</code>.<br />
 Check the <a href="https://github.com/skypjack/entt/blob/master/AUTHORS">contributors list</a> to see who has partecipated so far.</p>
<h1><a class="anchor" id="autotoc_md31"></a>
License</h1>
<p>Code and documentation Copyright (c) 2018 Michele Caini.<br />
 Code released under <a href="https://github.com/skypjack/entt/blob/master/LICENSE">the MIT license</a>. Docs released under <a href="https://github.com/skypjack/entt/blob/master/docs/LICENSE">Creative Commons</a>.</p>
<h1><a class="anchor" id="autotoc_md32"></a>
Donation</h1>
<p>Developing and maintaining <code>EnTT</code> takes some time and lots of coffee. I'd like to add more and more functionalities in future and turn it in a full-featured framework.<br />
 If you want to support this project, you can offer me an espresso. I'm from Italy, we're used to turning the best coffee ever in code. If you find that it's not enough, feel free to support me the way you prefer.<br />
 Take a look at the donation button at the top of the page for more details or just click <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_donations&amp;business=W2HF9FESD5LJY&amp;lc=IT&amp;item_name=Michele%20Caini&amp;currency_code=EUR&amp;bn=PP%2dDonationsBF%3abtn_donateCC_LG%2egif%3aNonHosted">here</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
