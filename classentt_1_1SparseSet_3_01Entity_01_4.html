<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>entt: entt::SparseSet&lt; Entity &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">entt
   &#160;<span id="projectnumber">2.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceentt.html">entt</a></li><li class="navelem"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html">SparseSet&lt; Entity &gt;</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classentt_1_1SparseSet_3_01Entity_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">entt::SparseSet&lt; Entity &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Basic sparse set implementation.  
 <a href="classentt_1_1SparseSet_3_01Entity_01_4.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for entt::SparseSet&lt; Entity &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classentt_1_1SparseSet_3_01Entity_01_4__inherit__graph.png" border="0" usemap="#entt_1_1SparseSet_3_01Entity_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="entt_1_1SparseSet_3_01Entity_01_4_inherit__map" id="entt_1_1SparseSet_3_01Entity_01_4_inherit__map">
<area shape="rect" id="node2" href="classentt_1_1SparseSet_3_01Entity_00_01Type_01_4.html" title="Extended sparse set implementation. " alt="" coords="9,80,172,121"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7d36e852257a965a9a0ed3fb636433e2"><td class="memItemLeft" align="right" valign="top"><a id="a7d36e852257a965a9a0ed3fb636433e2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a7d36e852257a965a9a0ed3fb636433e2">entity_type</a> = Entity</td></tr>
<tr class="memdesc:a7d36e852257a965a9a0ed3fb636433e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying entity identifier. <br /></td></tr>
<tr class="separator:a7d36e852257a965a9a0ed3fb636433e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c218a69cf339371251ffa5580d7aa0"><td class="memItemLeft" align="right" valign="top"><a id="a20c218a69cf339371251ffa5580d7aa0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a20c218a69cf339371251ffa5580d7aa0">pos_type</a> = <a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a7d36e852257a965a9a0ed3fb636433e2">entity_type</a></td></tr>
<tr class="memdesc:a20c218a69cf339371251ffa5580d7aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity dependent position type. <br /></td></tr>
<tr class="separator:a20c218a69cf339371251ffa5580d7aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81c48dcee7a1104ee82794613ee7ed2"><td class="memItemLeft" align="right" valign="top"><a id="ab81c48dcee7a1104ee82794613ee7ed2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#ab81c48dcee7a1104ee82794613ee7ed2">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:ab81c48dcee7a1104ee82794613ee7ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type. <br /></td></tr>
<tr class="separator:ab81c48dcee7a1104ee82794613ee7ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad77aed1e49af60b61044c996969b9a"><td class="memItemLeft" align="right" valign="top"><a id="a1ad77aed1e49af60b61044c996969b9a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a1ad77aed1e49af60b61044c996969b9a">iterator_type</a> = Iterator</td></tr>
<tr class="memdesc:a1ad77aed1e49af60b61044c996969b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input iterator type. <br /></td></tr>
<tr class="separator:a1ad77aed1e49af60b61044c996969b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abbb28cca309663bae49e1617f83ad76a"><td class="memItemLeft" align="right" valign="top"><a id="abbb28cca309663bae49e1617f83ad76a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#abbb28cca309663bae49e1617f83ad76a">SparseSet</a> () noexcept=default</td></tr>
<tr class="memdesc:abbb28cca309663bae49e1617f83ad76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:abbb28cca309663bae49e1617f83ad76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c078509aa5b611563c7d11f3a5114bf"><td class="memItemLeft" align="right" valign="top"><a id="a6c078509aa5b611563c7d11f3a5114bf"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a6c078509aa5b611563c7d11f3a5114bf">~SparseSet</a> () noexcept=default</td></tr>
<tr class="memdesc:a6c078509aa5b611563c7d11f3a5114bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a6c078509aa5b611563c7d11f3a5114bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ad5318f2be78e8e4336bdf4b012905"><td class="memItemLeft" align="right" valign="top"><a id="aa4ad5318f2be78e8e4336bdf4b012905"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#aa4ad5318f2be78e8e4336bdf4b012905">SparseSet</a> (const <a class="el" href="classentt_1_1SparseSet.html">SparseSet</a> &amp;)=delete</td></tr>
<tr class="memdesc:aa4ad5318f2be78e8e4336bdf4b012905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying a sparse set isn't allowed. <br /></td></tr>
<tr class="separator:aa4ad5318f2be78e8e4336bdf4b012905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfceb557303dee515fe906a13ac759e"><td class="memItemLeft" align="right" valign="top"><a id="acdfceb557303dee515fe906a13ac759e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#acdfceb557303dee515fe906a13ac759e">SparseSet</a> (<a class="el" href="classentt_1_1SparseSet.html">SparseSet</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:acdfceb557303dee515fe906a13ac759e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move constructor. <br /></td></tr>
<tr class="separator:acdfceb557303dee515fe906a13ac759e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ffc79377cef381ef5af2e75d61cf4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1SparseSet.html">SparseSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a34ffc79377cef381ef5af2e75d61cf4d">operator=</a> (const <a class="el" href="classentt_1_1SparseSet.html">SparseSet</a> &amp;)=delete</td></tr>
<tr class="memdesc:a34ffc79377cef381ef5af2e75d61cf4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying a sparse set isn't allowed.  <a href="#a34ffc79377cef381ef5af2e75d61cf4d">More...</a><br /></td></tr>
<tr class="separator:a34ffc79377cef381ef5af2e75d61cf4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ddfc9e45d7b70639124fe7c2800384"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1SparseSet.html">SparseSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a24ddfc9e45d7b70639124fe7c2800384">operator=</a> (<a class="el" href="classentt_1_1SparseSet.html">SparseSet</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a24ddfc9e45d7b70639124fe7c2800384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move assignment operator.  <a href="#a24ddfc9e45d7b70639124fe7c2800384">More...</a><br /></td></tr>
<tr class="separator:a24ddfc9e45d7b70639124fe7c2800384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337360e8d0f44c373acef65328a3e9f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#ab81c48dcee7a1104ee82794613ee7ed2">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a337360e8d0f44c373acef65328a3e9f8">size</a> () const noexcept</td></tr>
<tr class="memdesc:a337360e8d0f44c373acef65328a3e9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in a sparse set.  <a href="#a337360e8d0f44c373acef65328a3e9f8">More...</a><br /></td></tr>
<tr class="separator:a337360e8d0f44c373acef65328a3e9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6b9c98d2645d821c81ff7d3586ca27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a9d6b9c98d2645d821c81ff7d3586ca27">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a9d6b9c98d2645d821c81ff7d3586ca27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a sparse set is empty.  <a href="#a9d6b9c98d2645d821c81ff7d3586ca27">More...</a><br /></td></tr>
<tr class="separator:a9d6b9c98d2645d821c81ff7d3586ca27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4dda542e3d725dd963dea57bfb9cb1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a7d36e852257a965a9a0ed3fb636433e2">entity_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a6e4dda542e3d725dd963dea57bfb9cb1">data</a> () const noexcept</td></tr>
<tr class="memdesc:a6e4dda542e3d725dd963dea57bfb9cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the internal packed array.  <a href="#a6e4dda542e3d725dd963dea57bfb9cb1">More...</a><br /></td></tr>
<tr class="separator:a6e4dda542e3d725dd963dea57bfb9cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efc9899f2ede4fd8ea1840a7ed8dbc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a1ad77aed1e49af60b61044c996969b9a">iterator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a1efc9899f2ede4fd8ea1840a7ed8dbc7">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a1efc9899f2ede4fd8ea1840a7ed8dbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <a href="#a1efc9899f2ede4fd8ea1840a7ed8dbc7">More...</a><br /></td></tr>
<tr class="separator:a1efc9899f2ede4fd8ea1840a7ed8dbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c54395d55054437bfe179718e102181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a1ad77aed1e49af60b61044c996969b9a">iterator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a2c54395d55054437bfe179718e102181">end</a> () const noexcept</td></tr>
<tr class="memdesc:a2c54395d55054437bfe179718e102181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.  <a href="#a2c54395d55054437bfe179718e102181">More...</a><br /></td></tr>
<tr class="separator:a2c54395d55054437bfe179718e102181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6a33e6e65345bf028877efa74c5a5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a1b6a33e6e65345bf028877efa74c5a5e">has</a> (<a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a7d36e852257a965a9a0ed3fb636433e2">entity_type</a> entity) const noexcept</td></tr>
<tr class="memdesc:a1b6a33e6e65345bf028877efa74c5a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a sparse set contains an entity.  <a href="#a1b6a33e6e65345bf028877efa74c5a5e">More...</a><br /></td></tr>
<tr class="separator:a1b6a33e6e65345bf028877efa74c5a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa0a2c4f286228fc47d32761552bc13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a20c218a69cf339371251ffa5580d7aa0">pos_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a7aa0a2c4f286228fc47d32761552bc13">get</a> (<a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a7d36e852257a965a9a0ed3fb636433e2">entity_type</a> entity) const noexcept</td></tr>
<tr class="memdesc:a7aa0a2c4f286228fc47d32761552bc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of an entity in a sparse set.  <a href="#a7aa0a2c4f286228fc47d32761552bc13">More...</a><br /></td></tr>
<tr class="separator:a7aa0a2c4f286228fc47d32761552bc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb65da9a09f41dcf6ec433066a7891c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#adb65da9a09f41dcf6ec433066a7891c3">construct</a> (<a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a7d36e852257a965a9a0ed3fb636433e2">entity_type</a> entity)</td></tr>
<tr class="memdesc:adb65da9a09f41dcf6ec433066a7891c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns an entity to a sparse set.  <a href="#adb65da9a09f41dcf6ec433066a7891c3">More...</a><br /></td></tr>
<tr class="separator:adb65da9a09f41dcf6ec433066a7891c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4be1be8435da50621373c0bd737a1e8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#ab4be1be8435da50621373c0bd737a1e8">destroy</a> (<a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a7d36e852257a965a9a0ed3fb636433e2">entity_type</a> entity)</td></tr>
<tr class="memdesc:ab4be1be8435da50621373c0bd737a1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an entity from a sparse set.  <a href="#ab4be1be8435da50621373c0bd737a1e8">More...</a><br /></td></tr>
<tr class="separator:ab4be1be8435da50621373c0bd737a1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af122c1668ab1efbe0eca5792e9bae434"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#af122c1668ab1efbe0eca5792e9bae434">swap</a> (<a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a20c218a69cf339371251ffa5580d7aa0">pos_type</a> lhs, <a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a20c218a69cf339371251ffa5580d7aa0">pos_type</a> rhs) noexcept</td></tr>
<tr class="memdesc:af122c1668ab1efbe0eca5792e9bae434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the position of two entities in the internal packed array.  <a href="#af122c1668ab1efbe0eca5792e9bae434">More...</a><br /></td></tr>
<tr class="separator:af122c1668ab1efbe0eca5792e9bae434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6ff2340d8accf14bdaa83676cbc670"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a7a6ff2340d8accf14bdaa83676cbc670">respect</a> (const <a class="el" href="classentt_1_1SparseSet.html">SparseSet</a>&lt; Entity &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a7a6ff2340d8accf14bdaa83676cbc670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort entities according to their order in another sparse set.  <a href="#a7a6ff2340d8accf14bdaa83676cbc670">More...</a><br /></td></tr>
<tr class="separator:a7a6ff2340d8accf14bdaa83676cbc670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c62c65aeb0112e688f05d8f641cdab"><td class="memItemLeft" align="right" valign="top"><a id="ad1c62c65aeb0112e688f05d8f641cdab"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#ad1c62c65aeb0112e688f05d8f641cdab">reset</a> ()</td></tr>
<tr class="memdesc:ad1c62c65aeb0112e688f05d8f641cdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a sparse set. <br /></td></tr>
<tr class="separator:ad1c62c65aeb0112e688f05d8f641cdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Entity&gt;<br />
class entt::SparseSet&lt; Entity &gt;</h3>

<p>Basic sparse set implementation. </p>
<p>Sparse set or packed array or whatever is the name users give it.<br />
 Two arrays: an <em>external</em> one and an <em>internal</em> one; a <em>sparse</em> one and a <em>packed</em> one; one used for direct access through contiguous memory, the other one used to get the data through an extra level of indirection.<br />
 This is largely used by the <a class="el" href="classentt_1_1Registry.html" title="Fast and reliable entity-component system. ">Registry</a> to offer users the fastest access ever to the components. <a class="el" href="classentt_1_1View.html" title="Multi component view. ">View</a> and <a class="el" href="classentt_1_1PersistentView.html" title="Persistent view. ">PersistentView</a> are entirely designed around sparse sets.</p>
<p>This type of data structure is widely documented in the literature and on the web. This is nothing more than a customized implementation suitable for the purpose of the framework.</p>
<dl class="section note"><dt>Note</dt><dd>There are no guarantees that entities are returned in the insertion order when iterate a sparse set. Do not make assumption on the order in any case.</dd>
<dd>
Internal data structures arrange elements to maximize performance. Because of that, there are no guarantees that elements have the expected order when iterate directly the internal packed array (see <code>data</code> and <code>size</code> member functions for that). Use <code>begin</code> and <code>end</code> instead.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="structentt_1_1entt__traits.html" title="Entity traits. ">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00056">56</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a1efc9899f2ede4fd8ea1840a7ed8dbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efc9899f2ede4fd8ea1840a7ed8dbc7">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a1ad77aed1e49af60b61044c996969b9a">iterator_type</a> <a class="el" href="classentt_1_1SparseSet.html">entt::SparseSet</a>&lt; Entity &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<p>The returned iterator points to the first element of the internal packed array. If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a2c54395d55054437bfe179718e102181" title="Returns an iterator to the end. ">end()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>Input iterators stay true to the order imposed by a call to <code>sort</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first element of the internal packed array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00173">173</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="adb65da9a09f41dcf6ec433066a7891c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb65da9a09f41dcf6ec433066a7891c3">&#9670;&nbsp;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1SparseSet.html">entt::SparseSet</a>&lt; Entity &gt;::construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a7d36e852257a965a9a0ed3fb636433e2">entity_type</a>&#160;</td>
          <td class="paramname"><em>entity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns an entity to a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to assign an entity that already belongs to the sparse set results in undefined behavior.<br />
 An assertion will abort the execution at runtime in debug mode if the sparse set already contains the given entity.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00237">237</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a6e4dda542e3d725dd963dea57bfb9cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4dda542e3d725dd963dea57bfb9cb1">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a7d36e852257a965a9a0ed3fb636433e2">entity_type</a>* <a class="el" href="classentt_1_1SparseSet.html">entt::SparseSet</a>&lt; Entity &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the internal packed array. </p>
<p>The returned pointer is such that range <code>[<a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a6e4dda542e3d725dd963dea57bfb9cb1" title="Direct access to the internal packed array. ">data()</a>, <a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a6e4dda542e3d725dd963dea57bfb9cb1" title="Direct access to the internal packed array. ">data()</a> + <a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a337360e8d0f44c373acef65328a3e9f8" title="Returns the number of elements in a sparse set. ">size()</a>]</code> is always a valid range, even if the container is empty.</p>
<dl class="section note"><dt>Note</dt><dd>There are no guarantees on the order, even though <code>sort</code> has been previously invoked. Internal data structures arrange elements to maximize performance. Accessing them directly gives a performance boost but less guarantees. Use <code>begin</code> and <code>end</code> if you want to iterate the sparse set in the expected order.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the internal packed array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00157">157</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ab4be1be8435da50621373c0bd737a1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4be1be8435da50621373c0bd737a1e8">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classentt_1_1SparseSet.html">entt::SparseSet</a>&lt; Entity &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a7d36e852257a965a9a0ed3fb636433e2">entity_type</a>&#160;</td>
          <td class="paramname"><em>entity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an entity from a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to remove an entity that doesn't belong to the sparse set results in undefined behavior.<br />
 An assertion will abort the execution at runtime in debug mode if the sparse set doesn't contain the given entity.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classentt_1_1SparseSet_3_01Entity_00_01Type_01_4.html#a06b863abd1b457c48b7080e203b47a0f">entt::SparseSet&lt; Entity, Type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00264">264</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a9d6b9c98d2645d821c81ff7d3586ca27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6b9c98d2645d821c81ff7d3586ca27">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1SparseSet.html">entt::SparseSet</a>&lt; Entity &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a sparse set is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the sparse set is empty, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00138">138</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a2c54395d55054437bfe179718e102181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c54395d55054437bfe179718e102181">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a1ad77aed1e49af60b61044c996969b9a">iterator_type</a> <a class="el" href="classentt_1_1SparseSet.html">entt::SparseSet</a>&lt; Entity &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end. </p>
<p>The returned iterator points to the element following the last element in the internal packed array. Attempting to dereference the returned iterator results in undefined behavior.</p>
<dl class="section note"><dt>Note</dt><dd>Input iterators stay true to the order imposed by a call to <code>sort</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last element of the internal packed array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00190">190</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a7aa0a2c4f286228fc47d32761552bc13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa0a2c4f286228fc47d32761552bc13">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a20c218a69cf339371251ffa5580d7aa0">pos_type</a> <a class="el" href="classentt_1_1SparseSet.html">entt::SparseSet</a>&lt; Entity &gt;::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a7d36e852257a965a9a0ed3fb636433e2">entity_type</a>&#160;</td>
          <td class="paramname"><em>entity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of an entity in a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to get the position of an entity that doesn't belong to the sparse set results in undefined behavior.<br />
 An assertion will abort the execution at runtime in debug mode if the sparse set doesn't contain the given entity.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the entity in the sparse set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00219">219</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a1b6a33e6e65345bf028877efa74c5a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6a33e6e65345bf028877efa74c5a5e">&#9670;&nbsp;</a></span>has()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1SparseSet.html">entt::SparseSet</a>&lt; Entity &gt;::has </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a7d36e852257a965a9a0ed3fb636433e2">entity_type</a>&#160;</td>
          <td class="paramname"><em>entity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a sparse set contains an entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sparse set contains the entity, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00199">199</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a34ffc79377cef381ef5af2e75d61cf4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ffc79377cef381ef5af2e75d61cf4d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1SparseSet.html">SparseSet</a>&amp; <a class="el" href="classentt_1_1SparseSet.html">entt::SparseSet</a>&lt; Entity &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1SparseSet.html">SparseSet</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copying a sparse set isn't allowed. </p>
<dl class="section return"><dt>Returns</dt><dd>This sparse set. </dd></dl>

</div>
</div>
<a id="a24ddfc9e45d7b70639124fe7c2800384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ddfc9e45d7b70639124fe7c2800384">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1SparseSet.html">SparseSet</a>&amp; <a class="el" href="classentt_1_1SparseSet.html">entt::SparseSet</a>&lt; Entity &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1SparseSet.html">SparseSet</a>&lt; Entity &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default move assignment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>This sparse set. </dd></dl>

</div>
</div>
<a id="a7a6ff2340d8accf14bdaa83676cbc670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6ff2340d8accf14bdaa83676cbc670">&#9670;&nbsp;</a></span>respect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classentt_1_1SparseSet.html">entt::SparseSet</a>&lt; Entity &gt;::respect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1SparseSet.html">SparseSet</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort entities according to their order in another sparse set. </p>
<p>Entities that are part of both the sparse sets are ordered internally according to the order they have in <code>other</code>. All the other entities goes to the end of the list and there are no guarantess on their order.<br />
 In other terms, this function can be used to impose the same order on two sets by using one of them as a master and the other one as a slave.</p>
<p>Iterating the sparse set with a couple of iterators returns elements in the expected order after a call to <code>sort</code>. See <code>begin</code> and <code>end</code> for more details.</p>
<dl class="section note"><dt>Note</dt><dd>Attempting to iterate elements using the raw pointer returned by <code>data</code> gives no guarantees on the order, even though <code>sort</code> has been invoked.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sparse sets that imposes the order of the entities. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classentt_1_1SparseSet_3_01Entity_00_01Type_01_4.html#a73083f2d8385f8e33aebfadb2f657e7d">entt::SparseSet&lt; Entity, Type &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00319">319</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a337360e8d0f44c373acef65328a3e9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337360e8d0f44c373acef65328a3e9f8">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#ab81c48dcee7a1104ee82794613ee7ed2">size_type</a> <a class="el" href="classentt_1_1SparseSet.html">entt::SparseSet</a>&lt; Entity &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in a sparse set. </p>
<p>The number of elements is also the size of the internal packed array. There is no guarantee that the internal sparse array has the same size. Usually the size of the internal sparse array is equal or greater than the one of the internal packed array.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00130">130</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="af122c1668ab1efbe0eca5792e9bae434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af122c1668ab1efbe0eca5792e9bae434">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1SparseSet.html">entt::SparseSet</a>&lt; Entity &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a20c218a69cf339371251ffa5580d7aa0">pos_type</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1SparseSet_3_01Entity_01_4.html#a20c218a69cf339371251ffa5580d7aa0">pos_type</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the position of two entities in the internal packed array. </p>
<p>For what it's worth, this function affects both the internal sparse array and the internal packed array. Users should not care of that anyway.</p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to swap entities that don't belong to the sparse set results in undefined behavior.<br />
 An assertion will abort the execution at runtime in debug mode if the sparse set doesn't contain the given entities.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid position within the sparse set. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid position within the sparse set. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00293">293</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/entt/entity/<a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
